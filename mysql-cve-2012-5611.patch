Back-patched version of upstream fix for CVE-2012-5611.  Since Oracle
isn't publishing regression test cases anymore, I used MariaDB's test
case, but the fix itself is like Oracle's because that seems more
future-proof to me than MariaDB's version.

Note: the MariaDB test case included here doesn't reliably fail on
unpatched mysql 5.0.x.  The bug can be demonstrated on 5.0 though.


diff -Naur mysql-5.0.95.orig/mysql-test/r/information_schema.result mysql-5.0.95/mysql-test/r/information_schema.result
--- mysql-5.0.95.orig/mysql-test/r/information_schema.result	2011-12-16 07:22:48.000000000 -0500
+++ mysql-5.0.95/mysql-test/r/information_schema.result	2013-01-07 14:37:29.350636867 -0500
@@ -1439,3 +1439,8 @@
 SET max_heap_table_size = DEFAULT;
 USE test;
 End of 5.0 tests.
+grant usage on *.* to mysqltest_1@localhost;
+select 1 from information_schema.tables where table_schema=repeat('a', 2000);
+1
+drop user mysqltest_1@localhost;
+End of 5.1 tests.
diff -Naur mysql-5.0.95.orig/mysql-test/t/information_schema.test mysql-5.0.95/mysql-test/t/information_schema.test
--- mysql-5.0.95.orig/mysql-test/t/information_schema.test	2011-12-16 07:22:48.000000000 -0500
+++ mysql-5.0.95/mysql-test/t/information_schema.test	2013-01-07 14:38:09.924026566 -0500
@@ -1149,3 +1149,12 @@
 
 --echo End of 5.0 tests.
 
+grant usage on *.* to mysqltest_1@localhost;
+connect (con1, localhost, mysqltest_1,,);
+connection con1;
+select 1 from information_schema.tables where table_schema=repeat('a', 2000);
+connection default;
+disconnect con1;
+drop user mysqltest_1@localhost;
+
+--echo End of 5.1 tests.
diff -Naur mysql-5.0.95.orig/sql/sql_acl.cc mysql-5.0.95/sql/sql_acl.cc
--- mysql-5.0.95.orig/sql/sql_acl.cc	2011-12-16 07:12:41.000000000 -0500
+++ mysql-5.0.95/sql/sql_acl.cc	2013-01-07 14:45:16.688355139 -0500
@@ -1193,10 +1193,20 @@
 {
   ulong host_access= ~(ulong)0, db_access= 0;
   uint i,key_length;
+  size_t copy_length;
   char key[ACL_KEY_LENGTH],*tmp_db,*end;
   acl_entry *entry;
   DBUG_ENTER("acl_get");
 
+  copy_length= (size_t) (strlen(ip ? ip : "") +
+                 strlen(user ? user : "") +
+                 strlen(db ? db : ""));
+  /*
+    Make sure that strmov() operations do not result in buffer overflow.
+  */
+  if (copy_length >= ACL_KEY_LENGTH)
+    DBUG_RETURN(0);
+
   VOID(pthread_mutex_lock(&acl_cache->lock));
   end=strmov((tmp_db=strmov(strmov(key, ip ? ip : "")+1,user)+1),db);
   if (lower_case_table_names)
@@ -4004,6 +4014,16 @@
   char helping [NAME_LEN+USERNAME_LENGTH+2];
   uint len;
   bool error= TRUE;
+  size_t copy_length;
+
+  copy_length= (size_t) (strlen(sctx->priv_user ? sctx->priv_user : "") +
+                 strlen(db ? db : ""));
+
+  /*
+    Make sure that strmov() operations do not result in buffer overflow.
+  */
+  if (copy_length >= (NAME_LEN+USERNAME_LENGTH+2))
+    return 1;
 
   len= (uint) (strmov(strmov(helping, sctx->priv_user) + 1, db) - helping) + 1;
 
